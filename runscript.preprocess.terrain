#!/bin/bash
#!/bin/bash
#SBATCH --nodes=6
#SBATCH --ntasks-per-node=36
#SBATCH --time=6:00:00
#SBATCH --mail-type=BEGIN,END,FAIL
#SBATCH --mail-user=your.email@nrel.gov
#SBATCH --job-name='preprocess_terrain'




# User Input.

# For this case, a flat-terrain precursor was previously run. This path will be used as follows:
# - retrieve the original mesh
# - symlink constant/boundaryData
# - symlink constant/sources
precursorPath="/path/to/precursor/dir"

# TODO, if refineLevels==0 (EWQ):
# - copy over decomposed solution processor* subdirectories
# - call changeDictionary in parallel
# - do transformations (if any) in parallel

OpenFOAMversion=2.4.x-central   # OpenFOAM version
runNumber=3
startTime=20000                 # Start time
meshMotionTime=15               # Should match what's in system/controlDict.meshMotion
updateBCType=1                  # Boolean for whether or not the boundary condition types will be
                                #   updated over what is in the initial conditions files.
                                #   Leave it 0 for precursors
inflowDir='west'                # For inflow/outflow cases, specify the inflow direction.  Choices
                                #   are 'west', 'east', 'south', 'west', 'southWest', 'northWest',
                                #   'southEast', and 'northEast' (corresponding to changeDictionary
                                #   input files in the system directory). There is a 'cyclic' option
                                #   too in case you need to change back to cyclic or simply update
                                #   the number of boundary face entries.
cores=1008                      # Enter the number of cores you will preprocess on.

refinementLevels=0              # If you want to refine the mesh locally for any reason, or if you                                  #   are making a uniform resolution mesh that is so large that you
                                #   need to build it in serial at lower resolution and then globally
                                #   refine, set the number of refinement levels here. See the
                                #   refineMeshSerial and refineMeshParallel functions to understand
                                #   what they do.  The serial version runs topoSet and
                                #   refineHexMesh, so you need to provide system/topoSetDict.local.N
                                #   files where N corresponds to the refinement level (i.e., if you
                                #   are doing nested local refinement boxes. In most cases, though, 
                                #   you probably will not be refining, so keep this set to 0.


source SOWFAfunctions.sh

# Source the bash profile and then call the appropriate OpenFOAM version function
# so that all the modules and environment variables get set.
source $HOME/.bash_profile
OpenFOAM-$OpenFOAMversion


cp system/controlDict.meshMotion system/controlDict
cp system/fvSchemes.meshMotion system/fvSchemes
cp system/fvSolution.meshMotion system/fvSolution


# Grab to original setup to use as reference
cp $precursorPath/setUp .


# Copy the "clean" .original initial fields to a working copy.  OpenFOAM does not
# read the ".original" initial fields--that's why they remain clean.
# Note: This is for mesh motion only
rm -rf 0
cp -r 0.original 0
# Also copy the initial precursor fields
rm -rf $startTime
cp -rf $precursorPath/$startTime $startTime


# Get the inflow data linked up.
ln -s $precursorPath/postProcessing/boundaryData ./constant/


# Get the driving source terms linked up.
ln -s $precursorPath/postProcessing/sources ./constant/


# Copy over the original mesh.
cp -rf $precursorPath/constant/polyMesh/* constant/polyMesh/


# Do mesh transformations here (optional).
# - The mesh needs to be positioned such that the _maximum_ elevation coincides with the bottom of
#   the box mesh. The terrain-resolving mesh will be stretched _downward_ over the terrain.
transformPoints -translate '(0.0 0.0 494.0)' > log.transformPoints.translate 2>&1


# Update boundary patch type from 'cyclic' to 'patch'
changeDictionary -dict system/changeDictionaryDict.setTypePatch \
    -time 0 -enableFunctionEntries > log.changeDictionary.updateBCs.${inflowDir}.meshMotion 2>&1


# Do serial local refinement
refineMeshLocal $refinementLevels


# Decompose the mesh and solution files (serial)
decomposePar -time 0 -cellDist -force > log.decomposePar 2>&1


# Now deform the mesh so that it conforms to the terrain
srun moveDynamicMesh -parallel > log.moveDynamicMesh


# Save moved mesh
mkdir -p procdirs_movedmesh
mv processors* procdirs_movedmesh/
for i in `seq 0 $((cores-1))`; do
    mkdir -p processor$i
    cp -r procdirs_movedmesh/processor$i/constant processor$i/
    cp procdirs_movedmesh/processor$i/$meshMotionTime/polyMesh/points.gz \
        processor$i/constant/polyMesh/
done


# Map the fields 
decomposePar -time $startTime -fields > log.decomposePar 2>&1


# The initial fields come from the precursor (at $startTime), which is periodic on all sides.
# The turbine case has inflow and outflow.  Call the changeDictionary utility to make the south and
# north sides inflow and outflow.
if [ $updateBCType -eq 1 ]; then
    srun changeDictionary -dict system/changeDictionaryDict.updateBCs.$inflowDir \
        -time $startTime -enableFunctionEntries -parallel > log.changeDictionary.updateBCs.${inflowDir}.${runNumber} 2>&1
fi


# Renumber the mesh for better matrix solver performance.
srun renumberMesh -parallel -overwrite > log.renumberMesh 2>&1


# Check the mesh
srun checkMesh -parallel > log.checkMesh.$runNumber 2>&1


# Clean up for flow solver
cp system/fvSchemes.terrain system/fvSchemes
cp system/fvSolution.terrain system/fvSolution



