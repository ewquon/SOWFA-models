#!/bin/bash
#SBATCH --nodes=6
#SBATCH --ntasks-per-node=36
#SBATCH --time=1:00:00
#SBATCH --mail-type=BEGIN,END,FAIL
#SBATCH --mail-user=your.email@nrel.gov
#SBATCH --job-name='preprocess_terrain'




# User Input.

# For this case, a flat-terrain precursor was previously run. This path will be used as follows:
# - retrieve the original mesh
# - symlink constant/boundaryData
# - symlink constant/sources (in the future, for the unified solver)
# 
# TODO: symlink $startTime to the first available inflow snapshot
precursorPath="/scratch/equon/terrain_study/PS12_neutral_generic"

OpenFOAMversion=2.4.x-central   # OpenFOAM version
runNumber=3
startTime=20000                 # Start time
inletElevation=406.0            # Height of lower edge of inlet patch--this should be constant
                                #   provided that the inlet terrain has been smoothed and flattened.
                                #   This is the distance the precursor domain will be translated in
                                #   the +z direction.
meshMotionTime=10               # Should match what's in system/controlDict.meshMotion
updateBCType=1                  # Boolean for whether or not the boundary condition types will be
                                #   updated over what is in the initial conditions files.
                                #   Leave it 0 for precursors
inflowDir='west'                # For inflow/outflow cases, specify the inflow direction.  Choices
                                #   are 'west', 'east', 'south', 'west', 'southWest', 'northWest',
                                #   'southEast', and 'northEast' (corresponding to changeDictionary
                                #   input files in the system directory). There is a 'cyclic' option
                                #   too in case you need to change back to cyclic or simply update
                                #   the number of boundary face entries.
cores=1008                      # Enter the number of cores you will preprocess on.

refinementLevels=0              # If you want to refine the mesh locally for any reason, or if you                                  #   are making a uniform resolution mesh that is so large that you
                                #   need to build it in serial at lower resolution and then globally
                                #   refine, set the number of refinement levels here. See the
                                #   refineMeshSerial and refineMeshParallel functions to understand
                                #   what they do.  The serial version runs topoSet and
                                #   refineHexMesh, so you need to provide system/topoSetDict.local.N
                                #   files where N corresponds to the refinement level (i.e., if you
                                #   are doing nested local refinement boxes. In most cases, though, 
                                #   you probably will not be refining, so keep this set to 0.


source SOWFAfunctions.sh

# Source the bash profile and then call the appropriate OpenFOAM version function
# so that all the modules and environment variables get set.
source $HOME/.bash_profile
OpenFOAM-$OpenFOAMversion


#==============================================================================
# SETUP

cp system/controlDict.meshMotion system/controlDict
cp system/fvSchemes.meshMotion system/fvSchemes
cp system/fvSolution.meshMotion system/fvSolution


# Grab to original setup to use as reference
cp $precursorPath/setUp .


# Copy the "clean" .original initial fields to a working copy.  OpenFOAM does not
# read the ".original" initial fields--that's why they remain clean.
# Note: This is for *mesh motion only*
rm -rf 0
cp -r 0.original.meshMotion 0


# Get the inflow data linked up.
ln -s $precursorPath/postProcessing/boundaryData ./constant/


# Get the driving source terms linked up.
# Note: This is _not_ used by ABLTerrainSolver
ln -s $precursorPath/postProcessing/sources ./constant/


# Copy over the original mesh.
rm -rf constant/polyMesh
cp -rf $precursorPath/constant/polyMesh constant/

#==============================================================================
# MESH MOTION (to conform to the terrain)

# Do mesh transformations here (optional).
# - Since the boundary does not move, we want to translate the mesh so that the bottom coincides
#   the inlet bottom. I.e., the inlet boundary height is unchanged. The lower surface may be 
#   stretched vertically in both directions.
if [ `echo "$inletElevation != 0" | bc -l` -ne 0 ]; then
    transformPoints -translate "(0.0 0.0 $inletElevation)" > log.transformPoints.translate 2>&1

    # Shift the boundary data to coincide with the our new transformed mesh
    cd constant
    cp boundaryData/$inflowDir/points boundaryData/$inflowDir/points.original
    python translateBoundaryData.py $inflowDir $inletElevation
    cd ..
fi


# Update boundary patch type from 'cyclic' to 'patch'
changeDictionary \
    -dict system/changeDictionaryDict.setTypePatch \
    -time 0 -enableFunctionEntries \
    > log.changeDictionary.updateBCs.patch 2>&1


# Do serial local refinement
refineMeshLocal $refinementLevels


# Decompose the mesh and solution files (serial)
decomposePar -time 0 -cellDist -force > log.decomposePar.moveMesh 2>&1


# Now deform the mesh so that it conforms to the terrain
srun moveDynamicMesh -parallel > log.moveDynamicMesh


# Reconstruct the moved mesh
reconstructPar -time $meshMotionTime > log.reconstructPar.movedMesh
mv $meshMotionTime ${meshMotionTime}.moveDynamicMesh


# Save the moveDynamicMesh solution
mkdir savedProcessorDirs
mv processor* savedProcessorDirs/


# Restore boundary types to what it was before moveDynamicMesh
changeDictionary \
    -dict system/changeDictionaryDict.setTypeCyclic \
    -enableFunctionEntries \
    > log.changeDictionary.updateBCs.cyclic 2>&1


#==============================================================================
# PROCESS PRECURSOR FIELDS

# Copy the initial precursor fields
rm -rf $startTime
cp -rf $precursorPath/$startTime $startTime


# The initial fields come from the precursor (at $startTime), which is periodic on all sides.
# The turbine case has inflow and outflow.  Call the changeDictionary utility to make the south and
# north sides inflow and outflow.
if [ $updateBCType -eq 1 ]; then
    changeDictionary \
        -dict system/changeDictionaryDict.updateBCs.$inflowDir \
        -time $startTime -enableFunctionEntries \
        > log.changeDictionary.updateBCs.${inflowDir}.${startTime} 2>&1
fi


# Overwrite the old mesh
mv constant/polyMesh/points.gz constant/polyMesh/originalPoints.gz
cp ${meshMotionTime}.moveDynamicMesh/polyMesh/points.gz constant/polyMesh/


# Check the mesh
checkMesh -time $startTime > log.checkMesh.meshMoved


# Now, decompose the fields again (with the terrain-following mesh)
decomposePar -time $startTime -cellDist -force > log.decomposePar.$startTime 2>&1


# Renumber the mesh for better matrix solver performance.
srun renumberMesh -parallel -overwrite > log.renumberMesh 2>&1


# Check the mesh
srun checkMesh -parallel > log.checkMesh.$startTime 2>&1


# Clean up for flow solver
cp system/fvSchemes.terrain system/fvSchemes
cp system/fvSolution.terrain system/fvSolution



